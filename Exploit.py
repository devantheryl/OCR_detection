# -*- coding: utf-8 -*-
"""
Created on Wed Sep 21 16:43:58 2022

@author: LDE
"""

"""plannificateur permet l'ordonancement des lots sur la chaine de production"""



import sys

from functools import partial

# Import QApplication and the required widgets from PyQt5.QtWidgets
from PyQt5.QtCore import QDateTime, QDir
from PyQt5.QtWidgets import QApplication
from PyQt5.QtWidgets import QGridLayout
from PyQt5.QtWidgets import QLineEdit
from PyQt5.QtWidgets import QMainWindow
from PyQt5.QtWidgets import QPushButton
from PyQt5.QtWidgets import QVBoxLayout

from PyQt5.QtWidgets import QWidget
from PyQt5.QtWidgets import QComboBox
from PyQt5.QtWidgets import QDateEdit

from PyQt5.QtWidgets import QLabel
from PyQt5.QtWidgets import QPlainTextEdit
from PyQt5.QtWidgets import QFileDialog

from PyQt5.QtCore import QRunnable
from PyQt5.QtCore import QThreadPool
from PyQt5.QtCore import pyqtSlot
from PyQt5.QtCore import QTimer

import utils_camera
import utils_automate

import neoapi
import cv2 as cv
import pyads
from ctypes import sizeof
import os
from matplotlib import pyplot as plt

os.chdir("C:/Users/Administrator/Documents/OCR_detection")


import OCR_detection as ocr
import segment_vials as sv
import get_number
import cv2 as cv
from os import walk
import numpy as np
from sklearn.metrics import accuracy_score
from PIL import Image, ImageOps, ImageEnhance
import pandas as pd

import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.applications.resnet50 import ResNet50
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from tensorflow.keras.utils import to_categorical

import seaborn as sns
from tensorflow.keras.preprocessing.image import load_img, img_to_array, array_to_img, ImageDataGenerator
import time 
from analyse_img import analyse_img

__version__ = "0.1"
__author__ = "Lucas Devanth√©ry"

ERROR_MSG = "ERROR"



nbr_image = 0
first_second = False #first = True, second = False

previous_time_printer = time.time()
previous_time_img = time.time()
bad_images = []


plc = None
camera = None




# Create a subclass of QMainWindow to setup the calculator's GUI
class PyCalcUi(QMainWindow):
    """PyCalc's View (GUI)."""

    def __init__(self):
        """View initializer."""
        super().__init__()
        # Set some main window's properties
        self.setWindowTitle("OCR Detection")
        #self.setFixedSize(600, 600)
        # Set the central widget and the general layout
        self.generalLayout = QVBoxLayout()
        self._centralWidget = QWidget(self)
        self.setCentralWidget(self._centralWidget)
        self._centralWidget.setLayout(self.generalLayout)
        
        self.buttons = {}
        
        # Create the display and the buttons
        self._createDisplay()
        
        
        
        self.threadpool = QThreadPool()
        print("Multithreading with maximum %d threads" % self.threadpool.maxThreadCount())
        

    def _createDisplay(self):
        """Create the display layout."""
        self.display_layout = QVBoxLayout()
        
        """connect button"""
        self.connect_button = QPushButton("Connect")
        self.buttons["connect"] = self.connect_button
        self.connect_plainText = QPlainTextEdit()
        
        
        
   
        # Add the display to the general layout
        self.display_layout.addWidget(self.connect_button)
        self.display_layout.addWidget(self.connect_plainText)
        
        
        self.generalLayout.addLayout(self.display_layout)
        

class Worker(QRunnable):
    '''
    Worker thread
    '''

    def __init__(self, fn, img, first, nbr_image):
        super(Worker, self).__init__()
        self.fn = fn
        self.img = img
        self.first = first
        self.nbr_image

    @pyqtSlot()
    def run(self):
        '''
        Your code goes in this function
        '''
        global bad_images
        
        print("Thread start")
        passed,classes, problem =  self.fn(self.img, self.first)
        if not passed:
            test = time.time()
            print("not passed, classes : ", classes)
            scale_percent = 100 # percent of original size
            width = int(self.img.shape[1] * scale_percent / 100)
            height = int(self.img.shape[0] * scale_percent / 100)
            dim = (width, height)
            img = cv.resize(self.img,dim, interpolation = cv.INTER_AREA)
            #bad_images.append(self.first)
            
            cv.imwrite("bad_imgs/"+str(self.nbr_image)  + "_" +str(self.first)+ "-" + problem +".png", img)
            print("imwrite took : ", time.time()-test)
            
            
        #print("Thread complete")    




# Create a Controller class to connect the GUI and the model
class PyCalcCtrl:
    """PyCalc's Controller."""

    def __init__(self, model, view):
        """Controller initializer."""
        self._evaluate = model
        self._view = view
        # Connect signals and slots
        self._connectSignals()
        self.connected = False

            
    def _connect_disconnect(self):
        
        if self.connected:
            self._disconnect()
        else:
            self._connect()
        
    def _connect(self):
        
        global plc, camera
        
        self._view.connect_plainText.setPlainText("Connecting... \n")
        
        camera = utils_camera.connect_camera()
        plc = utils_automate.connect_automate()
        
        self._view.connect_plainText.appendPlainText("Current Status: " + str(plc.is_open) + "\n")
        self._view.connect_plainText.appendPlainText("Connected \n")
        self._view.buttons["connect"].setText("Disconnect")
        
        img_callback = ImageCallback(self)
        camera.EnableImageCallback(img_callback.imgcallback)        # enable the callback
        
        
        attr_printerSignal = pyads.NotificationAttrib(sizeof(pyads.PLCTYPE_BOOL))
        self.handles_printerSignal = plc.add_device_notification('main.bPrinterStart', attr_printerSignal, printer_callback)
        
        
        self.connected = True
        
        #set the flash on
        utils_automate.set_flash(plc, True)
        

    def _disconnect(self):
        
        global plc, camera
        
        self._view.connect_plainText.setPlainText("Closing the Connections.. \n")
        
        utils_automate.set_flash(plc, False)
        
        plc.del_device_notification(*self.handles_printerSignal)
        
        plc.close()
        
        utils_camera.disconnect_camera(camera)
        
        self._view.connect_plainText.appendPlainText("Current Status: " + str(plc.is_open) + "\n")
        self._view.connect_plainText.appendPlainText("disconnected \n")
        self._view.buttons["connect"].setText("Connect")
        
        
        self.connected = False

    def _connectSignals(self):
        """Connect signals and slots."""
        
        self._view.buttons["connect"].clicked.connect(partial(self._connect_disconnect))

        
        pass



    
    

def printer_callback(notification, data):
    global nbr_image
    global previous_time_printer
    global first_second
    handle, timestamp, value = plc.parse_notification(notification, pyads.PLCTYPE_BOOL)
    first_second = True
    if value:
        end = time.time()
        print("printer signal :", end - previous_time_printer)
        previous_time_printer = time.time()
        pass
    
# write the image callback
class ImageCallback:
    
    def __init__(self, ctrl):
        self.imgs = []
        self.ctrl = ctrl
        
    def imgcallback(self, image):
        global previous_time
        global nbr_image
        global imgs
        global first_second
        
        
        
        first_second = not first_second
        nbr_image = nbr_image+1
        
        image = image.GetNPArray()
        
        worker = Worker(analyse_img, image, first_second, nbr_image)
        
        print("here")
        self.ctrl._view.threadpool.start(worker)
        
        
        
        
        #print("image taken after :", time.time() - previous_time_img + "\n")
        """
        test = time.time()
        cv.imwrite("img/"+str(nbr_image)  + ".png", image)
        print("imwrite took : ", time.time()-test)
        """
        
        
    

# Client code
def main():
    """Main function."""
    # Create an instance of `QApplication`
    pycalc = QApplication(sys.argv)
    # Show the calculator's GUI
    view = PyCalcUi()
    view.show()
    # Create instances of the model and the controller
    model = None
    PyCalcCtrl(model=model, view=view)
    # Execute calculator's main loop
    sys.exit(pycalc.exec_())


if __name__ == "__main__":
    main()
